/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package piano;

import java.util.ArrayList;

import processing.core.PApplet;
import processing.core.PImage;

public class App extends PApplet{
    //1、定义要加载的图片背景对象
    PImage banner;
    PImage block;
    PImage buttonBack;
    PImage grid;
    PImage keyboard;
    PImage middleBanner;
    PImage pause;
    PImage play;
    PImage pointer;
    PImage stop;
    //定义游标的X坐标
    int pointerX;
    //定义准线的X坐标
    int pointX;
    //定义游标和准线的运行速度，因为游标准线是一起运动，所以同一个速度就可以了
    int pointerVX;
    //定义暂停开始的幂等标志位
    int flag = -1;
    Block blockPosition;
    //定义Block集合
    ArrayList<Block> blocks;
    //定义碰撞的滑块的个数
    int countBlocks = 0;

    public App(){
      blockPosition = new Block();
      blocks = new ArrayList<Block>();
    }

    @Override
    public void settings() {
      size(540,335);
      //设置app界面大小，这里的设置是固定的，不用修改，图片等相关尺寸都是设计好，不需要再修改
    }

    @Override
    public void setup() {
      //2、加载resource中的图片
      banner = loadImage("banner.png");
      block = loadImage("block.png");
      buttonBack = loadImage("buttonBack.png");
      grid = loadImage("grid.png");
      keyboard = loadImage("keyboard.png");
      middleBanner = loadImage("middleBanner.png");
      pause = loadImage("pause.png");
      play = loadImage("play.png");
      pointer = loadImage("pointer.png");
      stop = loadImage("stop.png");
      //设置游标准线的起始x坐标和速度
      pointerX = 49;
      pointX = 60;
      pointerVX = 0; 
    }
    
    @Override
    public void draw() {
      //3、绘画图片到APP界面上
      //draw()会按照代码顺序无限循环执行下面的代码，
      //所以图片加载的顺序很重要，后面加载的图片会覆盖前面的
      //part 1
      drawBackgroud();
      //part 2-1、2
      //绘制游标准线，此时游标准线已经可以运动了
      drawPointerAndButton();
      //绘制暂停，播放键
      //part 2-3
      drawButton();
      //绘制block
      drawBlock();
      //碰撞统计
      countBlocks = knockIntoBlock();
      if(countBlocks!=0){
        System.out.println(countBlocks + "个blocks");
      }
      
    }
    //part1：背景贴图
    public void drawBackgroud(){
      image(middleBanner, 0, 0);
      image(banner, 0, 0);
      image(buttonBack, 5, 5);
      image(buttonBack, 50, 5);
      image(keyboard, 0, 75);
      image(grid, 60, 75);
      //image(pause, 5, 5);
      //image(play, 5, 5);//这个是后来添加的
      image(stop, 50, 5);
    }

    /**
     * part2-1、2:绘制游标准线及运动
     */
    public void drawPointerAndButton(){
      //加载游标
      image(pointer, pointerX,59);
      //绘制准线
      //设置准线颜色
      stroke(255,0,0);//红色
      line(pointX, 75, pointX, height);
      //添加速度
      pointX += pointerVX;
      pointerX += pointerVX;
      //添加越界判断，让游标到做右边回到起始位置
      if(pointX == width){//如果准线x坐标等于UI的宽
        pointX = 60;//准线回到起始位置
        pointerX = 49;//游标回到起始位置
      }//只需要判断准线就够了，因为准线在游右边，先抵达边界
    }

    /**
     * part2-3：添加鼠标事件
     */
    public void mousePressed(){
      //事件判定添加到鼠标事件中，生效
      clickPlayAndPause();
      //控制准线
      ctrlPointer();
      //点击停止按钮
      clickStop();
      //点击grid绘制block
      clickGrid();
    }
    /**part2-3-1
     * 点击暂停播放按钮判定逻辑
     */
    public void clickPlayAndPause(){
      //mouseX,mouseY是鼠标点击在屏幕的坐标
      if(mouseX > 5 && mouseX < 45 && mouseY > 5 && mouseY < 45){//如果点击的是播放和暂停的按钮区域
        flag *= -1;//每按一次按钮，flag 运算一次乘以一次-1 
      }
    }
    /**
     * part 2 -5
     */
    public void clickStop(){
      //点击的区域是stop按钮
      if(mouseX > 50 && mouseX < 90 && mouseY > 5 && mouseY < 45){//cl
        //准线，游标归零
        pointX = 60;
        pointerX = 49;
        //速度归零
        pointerVX = 0;
        //播放暂停还原成播放按钮
        flag = -1;
      }
    }
    /**
     * part 2-3-2绘制按钮
     */
    public void drawButton(){
      if(flag == -1){//此处假定flag == -1时，是暂停
        //加载播放按钮，因为游标的初始状态静止的，而按钮要显示播放按钮，点击后切换成暂停
        image(play, 5, 5);
      }else{
        //加载暂停按钮
        image(pause,5, 5);
      }
    }
    /**
     * part 2-4,按钮控制准线运动
     */
    public void ctrlPointer(){
      if(flag == -1){//此处假定flag == -1时，是暂停
        pointerVX = 0;//暂停也就是速度为0
      }else{
        pointerVX = 1;
      }
    }
    /**
     * 绘制block
     */
    public void drawBlock(){
      //绘制一个block
      //image(block, blockPosition.getX(), blockPosition.getY());
      //遍历所有的集合
      for (Block blo : blocks) {
        image(block, blo.getX(), blo.getY());
      }
    }

    //part 3 -1 首先我们要界定鼠标点击的区域，只有点击区域在gridl内点击才会出现block
    public void clickGrid(){
      if(mouseX > 60 && mouseX < 540 && mouseY > 75 && mouseY < 335){//点击在Grid区域内
        blockPosition = new Block();//每点击一次就要创建一个新的Block
        //blockPosition.setX(mouseX);
        //blockPosition.setY(mouseY);
        //System.out.println(mouseX+","+mouseY);
        //计算block的坐标
        blockPosition.setX((int)((int)(mouseX - 60) / 15) * 15 + 60);
        blockPosition.setY((int)((int)(mouseY - 75) / 20) * 20 + 75);
        //blocks.add(blockPosition);
        if(blocks.contains(blockPosition)){//如果新点击的元素包含在原集合中
          blocks.remove(blockPosition);//已经存在就删除
        }else{
          blocks.add(blockPosition);//不存在就添加进去
        }
        //至此思路是完全对的，没有任何问题
      }
    }

    //part 4:碰撞检测
    public int knockIntoBlock(){
      int n = 0;
      for (Block blo : blocks) {
        if(blo.getX() == pointX){//block中点的x坐标和准线相等即视为碰撞
          n ++;//统计碰撞的点的个数，后面会用到
        }
      }
      return n;
    }


    public static void main(String[] args) {
        PApplet.main("piano.App");
    }
}
